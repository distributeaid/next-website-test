# Distribute Aid Shipment Visualisation

## Table of Contents

1. [Description](#description)
2. [Installation](#installation)
3. [Usage](#usage)
4. [Features](#features)
5. [Code Explanations](#code-explanations)
6. [Data Sources](#data-sources)
7. [Troubleshooting](#troubleshooting)
8. [Future Steps](#future-steps)
9. [Contact Information](#contact-information)

## Description

The Distribute Aid Shipment Visualization project aims to create a comprehensive website using open-source platforms to visualize and analyze aid shipment data. This project helps answer critical questions about aid distribution, shipment types, item frequency, shipment origins and destinations, and recipient needs over time. The insights drawn from the data can inform decision-making and improve the efficiency and effectiveness of aid distribution.

### Goals and Accomplishments

- **Purpose**: To provide a user-friendly interface for visualizing aid shipment data and extracting actionable insights.
- **Accomplishments**:
  - Developed an **Area Bump Chart** to visualize changes in aid shipment metrics over time.
  - Created a **Calendar Chart** to display the distribution of shipments across different segments.
  - Implemented a **Sunburst Chart** to represent hierarchical relationships in aid shipment data.

## Installation

### Prerequisites

- Node.js
- React library
- Nivo visualization library
- Axios for data fetching

### Setup

Install the dependencies:

```bash
npm install
```

## Usage

### Running the Application

To start the application, run:

```bash
npm run dev
```

The application will launch in your default web browser.

## Features

To view the different charts, add the following extensions to the URL generated by the local host. Detailed code explanations are included at the end of each chart. 

### Area Bump Chart: /data/aid-over-time

The AreaBumpChart (documentation from: https://nivo.rocks/area-bump/) was created to visualize changes in aid shipment metrics over time. This chart allows us to track and compare different projects or types of shipments over a specified period, highlighting trends and patterns. By analyzing the area bump chart, we can gain insights into which projects or shipment types have the most significant impact, how their performance evolves over time, and identify any seasonal variations or long-term trends. 

### Calendar Chart: /data/calendar

The CalendarChart (documentation from: https://nivo.rocks/calendar/) was developed to display the distribution of shipments across different segments and over time. This chart provides a clear, day-by-day view of shipment activity, making it easy to spot peak periods and identify days with high or low shipment volumes. By using the calendar chart, we can assess the operational workload, understand the temporal distribution of shipments, and optimize scheduling and resource management. It also helps in identifying patterns related to specific segments like 'Main Leg', 'First Mile', or 'Last Mile'.

### Sunburst Chart: /data/shipment-breakdown

The SunburstChart (documentation from https://nivo.rocks/sunburst/) was created to represent hierarchical relationships in aid shipment data. This chart allows us to drill down into multiple layers of data, providing a comprehensive view of how different categories, items, or groups are distributed and related. By using the sunburst chart, we can gain insights into the composition and breakdown of shipments, understand the distribution of aid across different countries or categories, and identify key areas of focus. This hierarchical visualization is valuable for detailed analysis and strategic planning in aid distribution.

## Code Explanations

### [Area Bump Chart](./AreaBumpChart.tsx) 

#### Component Props

- `selectedMetric`: A string that determines whether to display 'Count' or 'Total Needs Met'.
- `selectedFilter`: A string that determines the filter to be applied (e.g., 'Project / Response' or 'Type of Shipment').
- `startYear`: An integer defining the start year for the data filter.
- `endYear`: An integer defining the end year for the data filter.

```javascript
interface AreaBumpChartProps {
  selectedMetric: string;
  selectedFilter: string;
  startYear: number;
  endYear: number;
}
```
The `DataItem` interface defines the structure of the data used in the area bump chart, where `id` is a unique identifier for each dataset, and `data` is an array of objects representing the x (time) and y (value) coordinates for the chart. This is the data structure which the Area Bump Chart requires. 

```javascript
interface DataItem {
  id: string;
  data: { x: string; y: number }[];
}
```

#### Data Fetching

The component uses data imported from JSON files based on the selectedFilter and selectedMetric props. The data sets are imported manually from the following files: 

```javascript
import area_bump_project_counts from '../../data/areabumpchart/area_bump_project_count.json';
import area_bump_project_needs from '../../data/areabumpchart/area_bump_project_needs.json';
import area_bump_shipment_counts from '../../data/areabumpchart/area_bump_shipment_count.json';
import area_bump_shipment_needs from '../../data/areabumpchart/area_bump_shipment_needs.json';
```

The loadData function determines which data set to use based on the selected filter and metric:

```javascript
const loadData = useCallback((filter, metric) => {
  let selectedData = [];

  if (filter === 'Project / Response') {
    selectedData = metric === 'Count' ? area_bump_project_counts : area_bump_project_needs;
  } else {
    selectedData = metric === 'Count' ? area_bump_shipment_counts : area_bump_shipment_needs;
  }

  try {
    const filteredData = filterDataByYear(selectedData, startYear, endYear);
    setData(filteredData);
    setError(null);
  } catch (error) {
    console.error("Error filtering the area bump data", error);
    setError("Error filtering the area bump data");
  }
}, [startYear, endYear]);
```

#### Data Filtering 

The filterDataByYear function filters the data based on the startYear and endYear props.

```javascript
const filterDataByYear = (data, startYear, endYear) => {
  return data.map(item => ({
    ...item,
    data: item.data.filter(d => {
      const year = parseInt(d.x.split('-')[0]);
      return year >= startYear && year <= endYear;
    })
  })).filter(item => item.data.length > 0);
};
```

#### Chart Rendering

The component uses the ResponsiveAreaBump component from the Nivo library to render the area bump chart. Key settings and options used include:

- `data`: The data to be visualized.
- `margin`: Margins for the chart. The left and right margins are set to be 275 to allow more space for one of the texts to be displayed. 
- `spacing`: The spacing between area bumps.
- `colors`: The color scheme used for the chart.
- `blendMode`: The blend mode for the areas.
- `startLabel` and `endLabel`: Labels for the start and end of the bumps.
- `axisTop` and `axisBottom`: Configuration for the top and bottom axes.

```javascript
<ResponsiveAreaBump
  data={data}
  margin={{ top: 40, right: 275, bottom: 80, left: 275 }}
  spacing={15}
  colors={{ scheme: 'nivo' }}
  blendMode="multiply"
  startLabel="id"
  endLabel="id"
  axisTop={null}
  axisBottom={{
    tickSize: 5,
    tickPadding: 5,
    tickRotation: -45,
    legend: '',
    legendPosition: 'middle',
    legendOffset: 32
  }}
/>

```

#### Error Handling

If there is an error fetching the data, the component displays an error message.

```javascript
if (error) return <div>{error}</div>;
```

#### No Data Handling

If there is no data available for the selected filters, the component displays a message indicating this.

```javascript
{data.length > 0 ? (
  <ResponsiveAreaBump ... />
) : (
  <p>No data available for the selected filters</p>
)}
```

### [Calendar Chart](./CalendarChart.tsx)

#### Component Props

- `selectedSegment`: A string that determines which segment's data to display (e.g., 'Main Leg', 'First Mile', 'Last Mile', or 'Total').
- `startYear`: An integer defining the start year for the data filter.
- `endYear`: An integer defining the end year for the data filter.

```javascript
interface CalendarChartProps {
  selectedSegment: string;
  startYear: number;
  endYear: number;
}
```
The CalendarDataItem interface defines the structure of the data used in the calendar chart, where day is a string representing a specific date, and value is a number indicating the metric value for that date. This is the data structure which the Calendar Chart requires.

```javascript
interface CalendarDataItem {
  day: string;
  value: number;
}
```

#### Data Fetching

The component uses data imported from JSON files based on the selectedSegment prop. The data sets are imported manually from the following files:

```javascript
import calendar_first_mile_counts from '../../data/calendar/calendar_first_mile_counts.json';
import calendar_last_mile_counts from '../../data/calendar/calendar_last_mile_counts.json';
import calendar_main_leg_counts from '../../data/calendar/calendar_main_leg_counts.json';
import calendar_total_counts from '../../data/calendar/calendar_total_counts.json';
```

The loadData function determines which data set to use based on the selected segment and filters it by the specified year range:

```javascript
const loadData = useCallback((segment: string) => {
  let filteredData: CalendarDataItem[] = [];
  switch (segment) {
    case 'Main Leg':
      filteredData = filterDataByYear(calendar_main_leg_counts, startYear, endYear);
      break;
    case 'First Mile':
      filteredData = filterDataByYear(calendar_first_mile_counts, startYear, endYear);
      break;
    case 'Last Mile':
      filteredData = filterDataByYear(calendar_last_mile_counts, startYear, endYear);
      break;
    default:
      filteredData = filterDataByYear(calendar_total_counts, startYear, endYear);
  }
  setData(filteredData);
  setError(null);
}, [startYear, endYear]);
```

#### Data Filtering

The filterDataByYear function filters the data based on the startYear and endYear props.

```javascript
const filterDataByYear = (data: CalendarDataItem[], startYear: number, endYear: number): CalendarDataItem[] => {
  return data.filter(item => {
    const year = parseInt(item.day.split('-')[0]);
    return year >= startYear && year <= endYear;
  });
};
```

#### Dynamic Height Calculation

The component dynamically calculates the height of the calendar chart based on the number of years in the selected range. This ensures that the chart adjusts its height appropriately to fit the data. The value "175" was chosen due to aesthetics. 

```javascript
// Calculate dynamic height based on the number of years
const numberOfYears = endYear - startYear + 1;
const dynamicHeight = numberOfYears * 175; // 
```

#### Chart Rendering

The component uses the ResponsiveCalendar component from the Nivo library to render the calendar heatmap. Key settings and options used include:

- `data`: The data to be visualized.
- `from` and `to`: The date range for the calendar. Increment startYear by 1 was done to prevent an extra year row. 
- `emptyColor`: The color used for empty days.
- `colors`: The color scheme used for the heatmap.
- `margin`: Margins for the chart.
- `yearSpacing`: The space between years.
- `monthBorderColor` and `dayBorderColor`: The border color for months and days.
- `dayBorderWidth`: The border width for days.

```javascript
<ResponsiveCalendar
  data={data}
  from={`${startYear + 1}-01-01`}  // Increment startYear by 1 to prevent an extra year row
  to={lastMonthEnd}
  emptyColor="#eeeeee"
  colors={['#61cdbb', '#97e3d5', '#e8c1a0', '#f47560']}
  margin={{ top: 40, right: 40, bottom: 40, left: 40 }}
  yearSpacing={40}
  monthBorderColor="#ffffff"
  dayBorderWidth={2}
  dayBorderColor="#ffffff"
/>
```

#### Error Handling

If there is an error fetching the data, the component displays an error message.

```javascript
if (error) return <div>{error}</div>;
```

#### No Data Handling

If there is no data available for the selected filters, the component displays a message indicating this.

```javascript
{data.length > 0 ? (
  <ResponsiveCalendar ... />
) : (
  <p>No data available for the selected filters</p>
)}
```

### [Sunburst Chart](./SunburstChart.tsx)

#### Component Props

- `selectedView`: A string that determines the view to display (e.g., 'Sending/Receiving Groups' or 'Item/Category').
- `selectedGroup`: A string that determines whether to show 'Sending' or 'Receiving' data.
- `selectedMetric`: A string that determines whether to display 'Count' or 'Total Needs Met'.

```javascript
interface SunburstChartProps {
  selectedView: string;
  selectedGroup: string;
  selectedMetric: string;
}
```

The DataItem interface defines the structure of the data used in the sunburst chart, where id is a unique identifier for each dataset, and data is an array of objects representing the hierarchical structure of the sunburst chart.

```javascript
interface DataItem {
  id: string;
  data: { x: string; y: number }[];
}
```

#### Data Fetching

The component uses data imported from JSON files based on the selectedView, selectedGroup, and selectedMetric props. The data sets are imported manually from the following files:

```javascript
import sunburst_sending_group_count from '../../data/sunburstchart/sunburst_sending_group_count.json';
import sunburst_sending_group_needs from '../../data/sunburstchart/sunburst_sending_group_needs.json';
import sunburst_receiving_group_count from '../../data/sunburstchart/sunburst_receiving_group_count.json';
import sunburst_receiving_group_needs from '../../data/sunburstchart/sunburst_receiving_group_needs.json';
import sunburst_sending_category_count from '../../data/sunburstchart/sunburst_sending_category_count.json';
import sunburst_sending_category_needs from '../../data/sunburstchart/sunburst_sending_category_needs.json';
import sunburst_receiving_category_count from '../../data/sunburstchart/sunburst_receiving_category_count.json';
import sunburst_receiving_category_needs from '../../data/sunburstchart/sunburst_receiving_category_needs.json';
```
The loadData function determines which data set to use based on the selected view, group, and metric:

```javascript
const loadData = useCallback(() => {
  setLoading(true); // Set loading to true when starting to load data
  let data;
  if (selectedView === 'Sending/Receiving Groups') {
    if (selectedGroup === 'Sending') {
      data = selectedMetric === 'Count' ? sunburst_sending_group_count : sunburst_sending_group_needs;
    } else {
      data = selectedMetric === 'Count' ? sunburst_receiving_group_count : sunburst_receiving_group_needs;
    }
  } else {
    if (selectedGroup === 'Sending') {
      data = selectedMetric === 'Count' ? sunburst_sending_category_count : sunburst_sending_category_needs;
    } else {
      data = selectedMetric === 'Count' ? sunburst_receiving_category_count : sunburst_receiving_category_needs;
    }
  }

  setData(data);
  setOriginalData(data);
  setLoading(false); // Set loading to false once data is loaded
  setError(null);
}, [selectedView, selectedGroup, selectedMetric]);
```

#### Data Filtering

The assignColors function assigns colors to the nodes in the sunburst chart using a predefined color dictionary. If a node's name is not found in the dictionary, a fallback color is generated.

```javascript
const assignColors = (node: any) => {
  if (colorDictionary[node.name]) {
    node.color = colorDictionary[node.name];
  } else {
    node.color = `hsl(${Math.random() * 360}, 70%, 50%)`; // Fallback color
  }
  if (node.children) {
    node.children.forEach(assignColors);
  }
};

if (data.children) {
  data.children.forEach(assignColors);
}
```

#### Loading State

To improve user experience, the component includes a loading message displayed while data is being fetched:

```javascript
{loading ? (
  <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '600px' }}>
    <p>Loading data...</p>
  </div>
) : (
  ...
)}
```

#### Chart Rendering

The component uses the ResponsiveSunburst component from the Nivo library to render the sunburst chart. Key settings and options used include:

- `data`: The data to be visualized.
- `margin`: Margins for the chart.
- `id`: The property used to identify each segment.
- `value`: The property used to determine the size of each segment.
- `cornerRadius`: The corner radius for the segments.
- `borderWidth` and `borderColor`: The border settings for the segments. The border settings for the segments, increased to 4 to improve separation of data.
- `colors`: The color scheme used for the chart.
- `inheritColorFromParent`: Set to `false` to improve visibility.
- `childColor`: Configuration for the colors of child segments.
- `enableArcLabels` and `arcLabelsSkipAngle`: Configuration for arc labels, with the skip angle set to 35 to reduce clutter.
- `layers`: Custom layers for rendering additional elements on the chart.
- `tooltip`: Configuration for the tooltip to allow user to view details of segments of the chart.
- `animate`: Set to `false` to reduce lag when allowing user to drill-down to child segments.  

```javascript
<ResponsiveSunburst
  data={data}
  margin={{ top: 10, right: 10, bottom: 10, left: 10 }}
  id="name"
  value="value"
  cornerRadius={4}
  borderWidth={4}
  borderColor="white"
  colors={{ scheme: 'nivo' }}
  inheritColorFromParent={false}
  childColor={{
    from: 'color',
    modifiers: [['darker', 0.1]]
  }}
  enableArcLabels={true}
  arcLabelsSkipAngle={35}
  layers={['arcs', 'labels', 'arcLabels', ({ centerX, centerY }) => (
    <text
      x={centerX}
      y={centerY}
      textAnchor="middle"
      dominantBaseline="central"
      style={{
        fontSize: 14,
        fill: '#333',
      }}
    >
      {data.name}
    </text>
  )]}
  tooltip={({ id, value, color, percentage }) => (
    <div
      style={{
        padding: '5px 10px',
        background: '#333',
        color: '#fff',
      }}
    >
      <strong>ID:</strong> {id}<br />
      <strong>Value:</strong> {value}<br />
      <strong>Percentage:</strong> {Math.round(percentage * 100) / 100}%
    </div>
  )}
  theme={{
    tooltip: {
      container: {
        background: '#333',
        color: '#fff'
      }
    }
  }}
  animate={false}
  motionConfig="stiff"
  onClick={(node, event) => {
    const newData = { ...data };
    // Logic to drill down to the next level
    if (node.depth === 1) {
      newData.children = node.data.children;
      setData(newData);
    } else if (node.depth === 0) {
      loadData(); // Reset to the original data
    }
  }}
/>

```

#### Error Handling

If there is an error fetching the data, the component displays an error message.

```javascript
if (error) return <div>{error}</div>;
```

#### No Data Handling

If there is no data available for the selected filters, the component displays a message indicating this.

```javascript
{data.children && data.children.length > 0 ? (
  <ResponsiveSunburst ... />
) : (
  <p>No data available for the selected filters</p>
)}
```

## Data Sources 

The data used for the charts are manipulated from the excel file "7 - Exportable _ Shareable Data [EXT].xlsx" into the format required using Python. As the project will be integrated with the wider initiative to migrate onto Strapi, the data manipulation steps were documented under "issues" for further development and integration with the website. The links contain the data manipulation steps with detailed code explanations as well as the original data files: 
 
- Area Bump Chart: https://github.com/distributeaid/aggregated-public-information/issues/77
- Calendar Chart: https://github.com/distributeaid/aggregated-public-information/issues/78
- Sunburst Chart: https://github.com/distributeaid/aggregated-public-information/issues/79

## Troubleshooting

When using the various chart components (AreaBumpChart, CalendarChart, and SunburstChart), issues such as data formatting errors, rendering performance problems, or unexpected visual outputs may arise. To mitigate these issues, ensure that the data conforms to the expected structure and format, and consider optimizing some of the rendering settings for better performance.

For more detailed guidance on troubleshooting, advanced configuration options, and best practices, refer to the official Nivo documentation: https://nivo.rocks/

## Future Steps

The plan is to build more charts to focus on the medium to granular level (focusing on individual shipments), with detailed plan and priority highlighted in the Roadmap for Shipment Visualisation (all in the DistributeAid group has been granted access to edit): https://docs.google.com/spreadsheets/d/1IPjUM_-oprYApfoUsrsgvcmtRkAHovyZxWAO1Amd0Ew/edit?usp=sharing

Additionally, to ensure a seamless transition between the Strapi environment, the charts should eventually ingest data from Strapi. As such "issues" were created to formalise the request as part of DistributeAid's protocol under the link: https://github.com/distributeaid/aggregated-public-information/issues

## Contact Information

For any questions or concerns regarding the initial development and roadmapping of the aid visualisation, please contact:

- Name: Chien
- Email: liewchienchen@gmail.com
- GitHub: https://github.com/ChienChen99
